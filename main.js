/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FocusModePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  focusFolderPaths: [],
  visualEffect: "paragraph",
  enableTypewriterScroll: false,
  typewriterOffset: 30,
  enableFrontmatterHiding: true,
  enableZenUi: true,
  enableStatisticsDisplay: true,
  statisticsToShow: ["characters", "words"]
};
var FocusModeSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Focus Mode Settings" });
    new import_obsidian.Setting(containerEl).setName("Focus Folder Paths").setDesc("Folders where focus mode should be automatically enabled (one per line)").addTextArea(
      (text) => text.setPlaceholder("Journal\nProjects/Novel").setValue(this.plugin.settings.focusFolderPaths.join("\n")).onChange(async (value) => {
        this.plugin.settings.focusFolderPaths = value.split("\n").map((path) => path.trim()).filter((path) => path.length > 0);
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Visual Effects" });
    new import_obsidian.Setting(containerEl).setName("Focus Style").setDesc("Select the visual focus style").addDropdown(
      (dropdown) => dropdown.addOption("none", "None").addOption("paragraph", "Paragraph Focus").addOption("sentence", "Sentence Focus").addOption("active-line", "Active Line Focus").setValue(this.plugin.settings.visualEffect).onChange(async (value) => {
        this.plugin.settings.visualEffect = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Hide Frontmatter").setDesc("Hide YAML frontmatter in focus mode").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableFrontmatterHiding).onChange(async (value) => {
        this.plugin.settings.enableFrontmatterHiding = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Scroll & UI" });
    new import_obsidian.Setting(containerEl).setName("Typewriter Scroll").setDesc("Keep cursor centered vertically").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableTypewriterScroll).onChange(async (value) => {
        this.plugin.settings.enableTypewriterScroll = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Typewriter Offset").setDesc("Vertical position of the cursor (0% = top, 50% = center, 100% = bottom)").addSlider(
      (slider) => slider.setLimits(0, 100, 5).setValue(this.plugin.settings.typewriterOffset).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.typewriterOffset = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Zen UI").setDesc("Hide sidebars and other UI elements").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableZenUi).onChange(async (value) => {
        this.plugin.settings.enableZenUi = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Statistics Display" });
    new import_obsidian.Setting(containerEl).setName("Show Statistics").setDesc("Display writing statistics in the bottom-right corner").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableStatisticsDisplay).onChange(async (value) => {
        this.plugin.settings.enableStatisticsDisplay = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Statistics to Display").setDesc("Select which statistics to show").setClass("statistics-checkboxes");
    const statisticsContainer = containerEl.createDiv({ cls: "statistics-options" });
    const statisticOptions = [
      { key: "characters", label: "\u6587\u5B57\u6570\uFF08\u30B9\u30DA\u30FC\u30B9\u542B\u3080\uFF09" },
      { key: "charactersNoSpaces", label: "\u6587\u5B57\u6570\uFF08\u30B9\u30DA\u30FC\u30B9\u9664\u304F\uFF09" },
      { key: "words", label: "\u5358\u8A9E\u6570" },
      { key: "lines", label: "\u884C\u6570" },
      { key: "paragraphs", label: "\u6BB5\u843D\u6570" }
    ];
    statisticOptions.forEach((option) => {
      new import_obsidian.Setting(statisticsContainer).setName(option.label).addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.statisticsToShow.includes(option.key)).onChange(async (value) => {
          if (value) {
            if (!this.plugin.settings.statisticsToShow.includes(option.key)) {
              this.plugin.settings.statisticsToShow.push(option.key);
            }
          } else {
            this.plugin.settings.statisticsToShow = this.plugin.settings.statisticsToShow.filter(
              (stat) => stat !== option.key
            );
          }
          await this.plugin.saveSettings();
        })
      );
    });
  }
};

// src/focus-controller.ts
var FocusController = class {
  constructor() {
    this.effects = [];
    this.isFocusModeActive = false;
  }
  addEffect(effect) {
    this.effects.push(effect);
  }
  isActive() {
    return this.isFocusModeActive;
  }
  activate(leaf) {
    console.log("[FocusController] activate() called");
    this.isFocusModeActive = true;
    this.effects.forEach((effect) => {
      effect.enable(leaf);
    });
  }
  deactivate(leaf) {
    console.log("[FocusController] deactivate() called, isFocusModeActive:", this.isFocusModeActive);
    if (!this.isFocusModeActive)
      return;
    this.isFocusModeActive = false;
    this.effects.forEach((effect) => {
      effect.disable(leaf);
    });
  }
  toggle(leaf) {
    if (this.isFocusModeActive) {
      this.deactivate(leaf);
    } else {
      this.activate(leaf);
    }
  }
  update(leaf) {
    console.log("[FocusController] update() called, isFocusModeActive:", this.isFocusModeActive);
    if (this.isFocusModeActive) {
      this.effects.forEach((effect) => effect.update(leaf));
    }
  }
  restoreState() {
  }
};

// src/context-observer.ts
var import_obsidian2 = require("obsidian");
var ContextObserver = class {
  constructor(app, controller, settings) {
    this.app = app;
    this.controller = controller;
    this.settings = settings;
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  onActiveLeafChange(leaf, forceUpdate = false) {
    console.log("[ContextObserver] onActiveLeafChange called, forceUpdate:", forceUpdate);
    if (!leaf || !leaf.view)
      return;
    if (leaf.view instanceof import_obsidian2.FileView) {
      const file = leaf.view.file;
      if (file instanceof import_obsidian2.TFile) {
        const shouldActivate = this.shouldActivate(file);
        console.log("[ContextObserver] File:", file.path, "shouldActivate:", shouldActivate);
        if (shouldActivate) {
          if (forceUpdate && this.controller.isActive()) {
            this.controller.update(leaf);
          } else {
            this.controller.activate(leaf);
          }
        } else {
          this.controller.deactivate(leaf);
        }
      } else {
        console.log("[ContextObserver] Not a TFile, deactivating");
        this.controller.deactivate(leaf);
      }
    }
  }
  shouldActivate(file) {
    if (!this.settings.focusFolderPaths || this.settings.focusFolderPaths.length === 0) {
      console.log("[ContextObserver] No focus folder paths configured");
      return false;
    }
    const result = this.settings.focusFolderPaths.some(
      (folderPath) => file.path.startsWith(folderPath)
    );
    console.log("[ContextObserver] Checking paths:", this.settings.focusFolderPaths, "result:", result);
    return result;
  }
};

// src/effects/zen-ui-effect.ts
var ZenUiEffect = class {
  constructor(app, plugin) {
    this.previousLeftCollapsed = false;
    this.previousRightCollapsed = false;
    this.app = app;
    this.plugin = plugin;
  }
  enable(leaf) {
    if (!this.plugin.settings.enableZenUi)
      return;
    this.previousLeftCollapsed = this.app.workspace.leftSplit.collapsed;
    this.previousRightCollapsed = this.app.workspace.rightSplit.collapsed;
    if (!this.previousLeftCollapsed) {
      this.app.workspace.leftSplit.collapse();
    }
    if (!this.previousRightCollapsed) {
      this.app.workspace.rightSplit.collapse();
    }
  }
  disable(leaf) {
    if (!this.previousLeftCollapsed) {
      this.app.workspace.leftSplit.expand();
    }
    if (!this.previousRightCollapsed) {
      this.app.workspace.rightSplit.expand();
    }
  }
  update(leaf) {
  }
};

// src/effects/paragraph-dimmer-effect.ts
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");
var dimmedDecoration = import_view.Decoration.mark({ class: "focus-mode-dimmed" });
var paragraphDimmerPlugin = import_view.ViewPlugin.fromClass(
  class {
    constructor(view) {
      this.decorations = this.computeDecorations(view);
    }
    update(update) {
      if (update.docChanged || update.selectionSet || update.viewportChanged) {
        this.decorations = this.computeDecorations(update.view);
      }
    }
    computeDecorations(view) {
      const builder = new import_state.RangeSetBuilder();
      const { state } = view;
      const { doc, selection } = state;
      const activeLineStartPositions = /* @__PURE__ */ new Set();
      for (const range of selection.ranges) {
        const line = doc.lineAt(range.head);
        activeLineStartPositions.add(line.from);
      }
      for (const { from, to } of view.visibleRanges) {
        for (let pos = from; pos <= to; ) {
          const line = doc.lineAt(pos);
          if (!activeLineStartPositions.has(line.from)) {
            builder.add(line.from, line.from, dimmedDecoration);
          }
          pos = line.to + 1;
        }
      }
      return builder.finish();
    }
  },
  {
    decorations: (v) => v.decorations
  }
);
var ParagraphDimmerEffect = class {
  constructor(plugin) {
    this.activeLeaves = /* @__PURE__ */ new Set();
    this.plugin = plugin;
  }
  enable(leaf) {
    var _a;
    console.log("[ParagraphDimmer] enable() called, visualEffect:", this.plugin.settings.visualEffect);
    if (this.plugin.settings.visualEffect !== "paragraph")
      return;
    const editor = (_a = leaf.view.editor) == null ? void 0 : _a.cm;
    if (editor) {
      const contentEl = leaf.view.contentEl;
      contentEl.classList.add("focus-mode-paragraph-active");
      this.activeLeaves.add(leaf);
      console.log("[ParagraphDimmer] Enabled - added class 'focus-mode-paragraph-active'");
      editor.requestMeasure();
    } else {
      console.log("[ParagraphDimmer] No editor found");
    }
  }
  disable(leaf) {
    const contentEl = leaf.view.contentEl;
    contentEl.classList.remove("focus-mode-paragraph-active");
    this.activeLeaves.delete(leaf);
  }
  update(leaf) {
    if (this.plugin.settings.visualEffect !== "paragraph") {
      this.disable(leaf);
    } else {
      const contentEl = leaf.view.contentEl;
      if (!contentEl.classList.contains("focus-mode-paragraph-active")) {
        this.enable(leaf);
      }
    }
  }
};
// This extension should be registered in the main plugin
ParagraphDimmerEffect.extension = import_view.ViewPlugin.fromClass(
  class {
    constructor(view) {
      this.decorations = this.computeDecorations(view);
    }
    update(update) {
      if (update.docChanged || update.viewportChanged || update.selectionSet) {
        this.decorations = this.computeDecorations(update.view);
      }
    }
    computeDecorations(view) {
      const isEnabled = view.contentDOM.closest(".focus-mode-paragraph-active");
      console.log("[ParagraphDimmer Extension] computeDecorations - isEnabled:", !!isEnabled);
      if (!isEnabled) {
        return import_view.Decoration.none;
      }
      const builder = new import_state.RangeSetBuilder();
      const { state } = view;
      const { doc } = state;
      const selection = state.selection.main;
      const cursorLine = doc.lineAt(selection.head);
      let startLineNo = cursorLine.number;
      while (startLineNo > 1) {
        const line = doc.line(startLineNo - 1);
        if (line.length === 0) {
          break;
        }
        startLineNo--;
      }
      let endLineNo = cursorLine.number;
      while (endLineNo < doc.lines) {
        const line = doc.line(endLineNo + 1);
        if (line.length === 0) {
          break;
        }
        endLineNo++;
      }
      const startPos = doc.line(startLineNo).from;
      const endPos = doc.line(endLineNo).to;
      console.log(
        "[ParagraphDimmer Extension] Active paragraph range:",
        startPos,
        "-",
        endPos,
        "Lines:",
        startLineNo,
        "-",
        endLineNo
      );
      if (startPos > 0) {
        for (const { from, to } of view.visibleRanges) {
          if (from < startPos) {
            const end = Math.min(to, startPos);
            builder.add(from, end, dimmedDecoration);
          }
        }
      }
      if (endPos < doc.length) {
        for (const { from, to } of view.visibleRanges) {
          if (to > endPos) {
            const start = Math.max(from, endPos);
            builder.add(start, to, dimmedDecoration);
          }
        }
      }
      return builder.finish();
    }
  },
  {
    decorations: (v) => v.decorations
  }
);

// src/effects/frontmatter-hiding-effect.ts
var FrontmatterHidingEffect = class {
  // Using any to avoid circular dependency or complex type imports for now
  constructor(plugin) {
    this.plugin = plugin;
  }
  enable(leaf) {
    if (!this.plugin.settings.enableFrontmatterHiding)
      return;
    const contentEl = leaf.view.contentEl;
    contentEl.classList.add("focus-mode-hide-frontmatter");
  }
  disable(leaf) {
    const contentEl = leaf.view.contentEl;
    contentEl.classList.remove("focus-mode-hide-frontmatter");
  }
  update(leaf) {
    if (!this.plugin.settings.enableFrontmatterHiding) {
      this.disable(leaf);
    } else {
      const contentEl = leaf.view.contentEl;
      if (!contentEl.classList.contains("focus-mode-hide-frontmatter")) {
        this.enable(leaf);
      }
    }
  }
};

// src/effects/typewriter-scroll-effect.ts
var import_view2 = require("@codemirror/view");
var TypewriterScrollEffect = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  enable(leaf) {
    var _a;
    console.log("[TypewriterScroll] enable() called, enableTypewriterScroll:", this.plugin.settings.enableTypewriterScroll);
    if (!this.plugin.settings.enableTypewriterScroll)
      return;
    const editor = (_a = leaf.view.editor) == null ? void 0 : _a.cm;
    if (editor) {
      const contentEl = leaf.view.contentEl;
      contentEl.classList.add("focus-mode-typewriter");
      contentEl.dataset.typewriterOffset = this.plugin.settings.typewriterOffset.toString();
      console.log(
        "[TypewriterScroll] Enabled - added class 'focus-mode-typewriter', offset:",
        this.plugin.settings.typewriterOffset
      );
      editor.requestMeasure();
    } else {
      console.log("[TypewriterScroll] No editor found");
    }
  }
  disable(leaf) {
    const contentEl = leaf.view.contentEl;
    contentEl.classList.remove("focus-mode-typewriter");
    delete contentEl.dataset.typewriterOffset;
  }
  update(leaf) {
    const contentEl = leaf.view.contentEl;
    if (this.plugin.settings.enableTypewriterScroll) {
      if (!contentEl.classList.contains("focus-mode-typewriter")) {
        this.enable(leaf);
      } else {
        contentEl.dataset.typewriterOffset = this.plugin.settings.typewriterOffset.toString();
      }
    } else {
      this.disable(leaf);
    }
  }
};
TypewriterScrollEffect.extension = import_view2.EditorView.updateListener.of((update) => {
  console.log("[TypewriterScroll Extension] updateListener called");
  const contentEl = update.view.contentDOM.closest(".focus-mode-typewriter");
  console.log(
    "[TypewriterScroll Extension] isEnabled:",
    !!contentEl,
    "selectionSet:",
    update.selectionSet,
    "docChanged:",
    update.docChanged
  );
  if (!contentEl)
    return;
  if (!update.selectionSet && !update.docChanged)
    return;
  const offsetPercent = parseInt(contentEl.dataset.typewriterOffset || "50", 10);
  const cursorPos = update.state.selection.main.head;
  const cursorCoords = update.view.coordsAtPos(cursorPos);
  if (!cursorCoords) {
    console.log("[TypewriterScroll Extension] No cursor coords");
    return;
  }
  const viewportHeight = update.view.scrollDOM.clientHeight;
  const scrollTop = update.view.scrollDOM.scrollTop;
  const cursorRelativeToViewport = cursorCoords.top - update.view.scrollDOM.getBoundingClientRect().top;
  const targetPosition = viewportHeight * (offsetPercent / 100);
  const scrollAdjustment = cursorRelativeToViewport - targetPosition;
  console.log(
    "[TypewriterScroll Extension] Scrolling - cursorY:",
    cursorRelativeToViewport,
    "target:",
    targetPosition,
    "adjustment:",
    scrollAdjustment
  );
  if (Math.abs(scrollAdjustment) > 1) {
    const newScrollTop = scrollTop + scrollAdjustment;
    update.view.scrollDOM.scrollTo({
      top: newScrollTop,
      behavior: "smooth"
    });
  }
});

// src/effects/chrome-hiding-effect.ts
var ChromeHidingEffect = class {
  constructor(app, plugin) {
    this.app = app;
    this.plugin = plugin;
  }
  enable(leaf) {
    if (!this.plugin.settings.enableZenUi)
      return;
    document.body.classList.add("focus-mode-chrome-hidden");
  }
  disable(leaf) {
    document.body.classList.remove("focus-mode-chrome-hidden");
  }
  update(leaf) {
  }
};

// src/effects/sentence-focus-effect.ts
var import_view3 = require("@codemirror/view");
var import_state2 = require("@codemirror/state");
var dimmedDecoration2 = import_view3.Decoration.mark({ class: "focus-mode-dimmed" });
var SentenceFocusEffect = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  enable(leaf) {
    if (this.plugin.settings.visualEffect !== "sentence")
      return;
    const contentEl = leaf.view.contentEl;
    contentEl.classList.add("focus-mode-sentence-active");
  }
  disable(leaf) {
    const contentEl = leaf.view.contentEl;
    contentEl.classList.remove("focus-mode-sentence-active");
  }
  update(leaf) {
    if (this.plugin.settings.visualEffect !== "sentence") {
      this.disable(leaf);
    } else {
      const contentEl = leaf.view.contentEl;
      if (!contentEl.classList.contains("focus-mode-sentence-active")) {
        this.enable(leaf);
      }
    }
  }
};
SentenceFocusEffect.extension = import_view3.ViewPlugin.fromClass(
  class {
    constructor(view) {
      this.decorations = this.computeDecorations(view);
    }
    update(update) {
      if (update.docChanged || update.selectionSet || update.viewportChanged) {
        this.decorations = this.computeDecorations(update.view);
      }
    }
    computeDecorations(view) {
      const isEnabled = view.contentDOM.closest(".focus-mode-sentence-active");
      if (!isEnabled) {
        return import_view3.Decoration.none;
      }
      const builder = new import_state2.RangeSetBuilder();
      const { state } = view;
      const { doc, selection } = state;
      const activeRanges = [];
      for (const range of selection.ranges) {
        const pos = range.head;
        const line = doc.lineAt(pos);
        const text = line.text;
        const relativePos = pos - line.from;
        let start = 0;
        let end = text.length;
        const sentenceEndPunctuation = /[.!?。！？]/;
        const closingQuotes = /[」』]/;
        for (let i = relativePos - 1; i >= 0; i--) {
          const char = text[i];
          if (sentenceEndPunctuation.test(char)) {
            const nextChar = i + 1 < text.length ? text[i + 1] : "";
            const charAfterNext = i + 2 < text.length ? text[i + 2] : "";
            if (closingQuotes.test(nextChar)) {
              if (charAfterNext && charAfterNext.trim()) {
                continue;
              } else {
                start = i + 2;
                break;
              }
            } else {
              start = i + 1;
              break;
            }
          } else if (closingQuotes.test(char)) {
            const nextChar = i + 1 < text.length ? text[i + 1] : "";
            if (!nextChar || !nextChar.trim()) {
              start = i + 1;
              break;
            }
          }
        }
        for (let i = relativePos; i < text.length; i++) {
          const char = text[i];
          if (sentenceEndPunctuation.test(char)) {
            const nextChar = i + 1 < text.length ? text[i + 1] : "";
            const charAfterNext = i + 2 < text.length ? text[i + 2] : "";
            if (closingQuotes.test(nextChar)) {
              if (charAfterNext && charAfterNext.trim()) {
                continue;
              } else {
                end = i + 2;
                break;
              }
            } else {
              end = i + 1;
              break;
            }
          } else if (closingQuotes.test(char)) {
            let hasTextAfter = false;
            for (let j = i + 1; j < text.length; j++) {
              if (text[j].trim()) {
                hasTextAfter = true;
                break;
              }
            }
            if (!hasTextAfter) {
              end = i + 1;
              break;
            }
          }
        }
        activeRanges.push({ from: line.from + start, to: line.from + end });
      }
      activeRanges.sort((a, b) => a.from - b.from);
      const mergedRanges = [];
      if (activeRanges.length > 0) {
        let current = activeRanges[0];
        for (let i = 1; i < activeRanges.length; i++) {
          if (activeRanges[i].from <= current.to) {
            current.to = Math.max(current.to, activeRanges[i].to);
          } else {
            mergedRanges.push(current);
            current = activeRanges[i];
          }
        }
        mergedRanges.push(current);
      }
      for (const { from, to } of view.visibleRanges) {
        let pos = from;
        for (const active of mergedRanges) {
          if (active.to < pos)
            continue;
          if (active.from > to)
            break;
          if (pos < active.from) {
            builder.add(pos, active.from, dimmedDecoration2);
          }
          pos = Math.max(pos, active.to);
        }
        if (pos < to) {
          builder.add(pos, to, dimmedDecoration2);
        }
      }
      return builder.finish();
    }
  },
  {
    decorations: (v) => v.decorations
  }
);

// src/effects/active-line-focus-effect.ts
var import_view4 = require("@codemirror/view");
var import_state3 = require("@codemirror/state");
var dimmedDecoration3 = import_view4.Decoration.mark({ class: "focus-mode-dimmed" });
var ActiveLineFocusEffect = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  enable(leaf) {
    console.log("[ActiveLineFocus] enable() called, visualEffect:", this.plugin.settings.visualEffect);
    if (this.plugin.settings.visualEffect !== "active-line")
      return;
    const contentEl = leaf.view.contentEl;
    contentEl.classList.add("focus-mode-active-line");
    console.log("[ActiveLineFocus] Enabled - added class 'focus-mode-active-line'");
  }
  disable(leaf) {
    const contentEl = leaf.view.contentEl;
    contentEl.classList.remove("focus-mode-active-line");
  }
  update(leaf) {
    if (this.plugin.settings.visualEffect !== "active-line") {
      this.disable(leaf);
    } else {
      const contentEl = leaf.view.contentEl;
      if (!contentEl.classList.contains("focus-mode-active-line")) {
        this.enable(leaf);
      }
    }
  }
};
// ViewPlugin extension to apply decoration to active line
ActiveLineFocusEffect.extension = import_view4.ViewPlugin.fromClass(
  class {
    constructor(view) {
      console.log("[ActiveLineFocus Extension] ViewPlugin constructor called");
      this.decorations = this.computeDecorations(view);
    }
    update(update) {
      if (update.selectionSet || update.viewportChanged) {
        this.decorations = this.computeDecorations(update.view);
      }
    }
    computeDecorations(view) {
      const isEnabled = view.contentDOM.closest(".focus-mode-active-line");
      console.log("[ActiveLineFocus Extension] computeDecorations - isEnabled:", !!isEnabled);
      if (!isEnabled) {
        return import_view4.Decoration.none;
      }
      const builder = new import_state3.RangeSetBuilder();
      const { state } = view;
      const { doc } = state;
      const activeLine = state.doc.lineAt(state.selection.main.head);
      const activeLineFrom = activeLine.from;
      const activeLineTo = activeLine.to;
      console.log("[ActiveLineFocus Extension] Active line at pos:", activeLineFrom, "to", activeLineTo);
      if (activeLineFrom > 0) {
        for (const { from, to } of view.visibleRanges) {
          if (from < activeLineFrom) {
            const end = Math.min(to, activeLineFrom);
            builder.add(from, end, dimmedDecoration3);
          }
        }
      }
      if (activeLineTo < doc.length) {
        for (const { from, to } of view.visibleRanges) {
          if (to > activeLineTo) {
            const start = Math.max(from, activeLineTo);
            builder.add(start, to, dimmedDecoration3);
          }
        }
      }
      const decorations = builder.finish();
      console.log("[ActiveLineFocus Extension] Returning decorations, size:", decorations.size);
      return decorations;
    }
  },
  {
    decorations: (v) => v.decorations
  }
);

// src/effects/statistics-display-effect.ts
var import_obsidian3 = require("obsidian");
var import_view5 = require("@codemirror/view");
var StatisticsDisplayEffect = class {
  constructor(app, plugin) {
    this.app = app;
    this.plugin = plugin;
  }
  enable(leaf) {
    if (!this.plugin.settings.enableStatisticsDisplay)
      return;
    const view = leaf.view;
    if (!(view instanceof import_obsidian3.MarkdownView))
      return;
    const contentEl = view.contentEl;
    if (!contentEl.querySelector(".focus-mode-statistics-overlay")) {
      const overlayElement = createDiv({ cls: "focus-mode-statistics-overlay" });
      contentEl.appendChild(overlayElement);
      contentEl.dataset.statisticsEnabled = "true";
      contentEl.dataset.statisticsToShow = JSON.stringify(this.plugin.settings.statisticsToShow);
      this.updateOverlay(view, overlayElement);
    }
  }
  disable(leaf) {
    const view = leaf.view;
    if (!(view instanceof import_obsidian3.MarkdownView))
      return;
    const contentEl = view.contentEl;
    const overlayElement = contentEl.querySelector(".focus-mode-statistics-overlay");
    if (overlayElement) {
      overlayElement.remove();
    }
    delete contentEl.dataset.statisticsEnabled;
    delete contentEl.dataset.statisticsToShow;
  }
  update(leaf) {
    const view = leaf.view;
    if (!(view instanceof import_obsidian3.MarkdownView))
      return;
    const contentEl = view.contentEl;
    const overlayElement = contentEl.querySelector(".focus-mode-statistics-overlay");
    if (this.plugin.settings.enableStatisticsDisplay) {
      contentEl.dataset.statisticsEnabled = "true";
      contentEl.dataset.statisticsToShow = JSON.stringify(this.plugin.settings.statisticsToShow);
      if (!overlayElement) {
        this.enable(leaf);
      } else {
        this.updateOverlay(view, overlayElement);
      }
    } else {
      if (overlayElement) {
        this.disable(leaf);
      }
    }
  }
  updateOverlay(view, overlayElement) {
    const editor = view.editor;
    if (!editor)
      return;
    const text = editor.getValue();
    const stats = this.calculateStatistics(text);
    const statisticsToShow = this.plugin.settings.statisticsToShow || ["characters", "words"];
    this.renderStatistics(overlayElement, stats, statisticsToShow);
  }
  calculateStatistics(text) {
    const characters = text.length;
    const charactersNoSpaces = text.replace(/\s/g, "").length;
    const words = text.trim().split(/\s+/).filter((word) => word.length > 0).length;
    const lines = text.split("\n").length;
    const paragraphs = text.split(/\n\s*\n/).filter((para) => para.trim().length > 0).length;
    return {
      characters,
      charactersNoSpaces,
      words,
      lines,
      paragraphs
    };
  }
  renderStatistics(overlayElement, stats, statsToShow) {
    overlayElement.empty();
    const displayOrder = [
      { key: "characters", label: "\u6587\u5B57\u6570", value: stats.characters },
      { key: "charactersNoSpaces", label: "\u6587\u5B57\u6570\uFF08\u7A7A\u767D\u9664\u304F\uFF09", value: stats.charactersNoSpaces },
      { key: "words", label: "\u5358\u8A9E\u6570", value: stats.words },
      { key: "lines", label: "\u884C\u6570", value: stats.lines },
      { key: "paragraphs", label: "\u6BB5\u843D\u6570", value: stats.paragraphs }
    ];
    displayOrder.forEach((stat) => {
      if (!statsToShow.includes(stat.key))
        return;
      const statItem = overlayElement.createDiv({ cls: "stat-item" });
      statItem.createSpan({ cls: "stat-label", text: stat.label + ": " });
      statItem.createSpan({ cls: "stat-value", text: this.formatNumber(stat.value) });
    });
  }
  formatNumber(num) {
    return num.toLocaleString();
  }
};
StatisticsDisplayEffect.extension = import_view5.EditorView.updateListener.of((update) => {
  var _a;
  const contentEl = (_a = update.view.contentDOM.closest(".markdown-source-view")) == null ? void 0 : _a.parentElement;
  if (!contentEl || contentEl.dataset.statisticsEnabled !== "true")
    return;
  if (!update.docChanged)
    return;
  const overlayElement = contentEl.querySelector(".focus-mode-statistics-overlay");
  if (!overlayElement)
    return;
  const text = update.state.doc.toString();
  const characters = text.length;
  const charactersNoSpaces = text.replace(/\s/g, "").length;
  const words = text.trim().split(/\s+/).filter((word) => word.length > 0).length;
  const lines = text.split("\n").length;
  const paragraphs = text.split(/\n\s*\n/).filter((para) => para.trim().length > 0).length;
  const stats = {
    characters,
    charactersNoSpaces,
    words,
    lines,
    paragraphs
  };
  const statisticsToShow = JSON.parse(contentEl.dataset.statisticsToShow || '["characters", "words"]');
  overlayElement.empty();
  const displayOrder = [
    { key: "characters", label: "\u6587\u5B57\u6570", value: stats.characters },
    { key: "charactersNoSpaces", label: "\u6587\u5B57\u6570\uFF08\u7A7A\u767D\u9664\u304F\uFF09", value: stats.charactersNoSpaces },
    { key: "words", label: "\u5358\u8A9E\u6570", value: stats.words },
    { key: "lines", label: "\u884C\u6570", value: stats.lines },
    { key: "paragraphs", label: "\u6BB5\u843D\u6570", value: stats.paragraphs }
  ];
  displayOrder.forEach((stat) => {
    if (!statisticsToShow.includes(stat.key))
      return;
    const statItem = overlayElement.createDiv({ cls: "stat-item" });
    statItem.createSpan({ cls: "stat-label", text: stat.label + ": " });
    statItem.createSpan({ cls: "stat-value", text: stat.value.toLocaleString() });
  });
});

// src/main.ts
var FocusModePlugin = class extends import_obsidian4.Plugin {
  async onload() {
    await this.loadSettings();
    this.controller = new FocusController();
    const zenUiEffect = new ZenUiEffect(this.app, this);
    const paragraphDimmerEffect = new ParagraphDimmerEffect(this);
    const frontmatterHidingEffect = new FrontmatterHidingEffect(this);
    const typewriterScrollEffect = new TypewriterScrollEffect(this);
    const chromeHidingEffect = new ChromeHidingEffect(this.app, this);
    const sentenceFocusEffect = new SentenceFocusEffect(this);
    const activeLineFocusEffect = new ActiveLineFocusEffect(this);
    const statisticsDisplayEffect = new StatisticsDisplayEffect(this.app, this);
    this.controller.addEffect(zenUiEffect);
    this.controller.addEffect(paragraphDimmerEffect);
    this.controller.addEffect(frontmatterHidingEffect);
    this.controller.addEffect(typewriterScrollEffect);
    this.controller.addEffect(chromeHidingEffect);
    this.controller.addEffect(sentenceFocusEffect);
    this.controller.addEffect(activeLineFocusEffect);
    this.controller.addEffect(statisticsDisplayEffect);
    console.log("[Main] Registering CM6 Extensions");
    console.log("[Main] ParagraphDimmerEffect.extension:", ParagraphDimmerEffect.extension);
    this.registerEditorExtension(ParagraphDimmerEffect.extension);
    console.log("[Main] TypewriterScrollEffect.extension:", TypewriterScrollEffect.extension);
    this.registerEditorExtension(TypewriterScrollEffect.extension);
    console.log("[Main] SentenceFocusEffect.extension:", SentenceFocusEffect.extension);
    this.registerEditorExtension(SentenceFocusEffect.extension);
    console.log("[Main] ActiveLineFocusEffect.extension:", ActiveLineFocusEffect.extension);
    this.registerEditorExtension(ActiveLineFocusEffect.extension);
    console.log("[Main] StatisticsDisplayEffect.extension:", StatisticsDisplayEffect.extension);
    this.registerEditorExtension(StatisticsDisplayEffect.extension);
    this.observer = new ContextObserver(this.app, this.controller, this.settings);
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", (leaf) => {
        this.observer.onActiveLeafChange(leaf);
      })
    );
    this.addCommand({
      id: "toggle-focus-mode",
      name: "Toggle Focus Mode",
      callback: () => {
        const leaf = this.app.workspace.getLeaf(false);
        if (leaf) {
          this.controller.toggle(leaf);
        }
      }
    });
    this.addCommand({
      id: "toggle-paragraph-focus",
      name: "Toggle Paragraph Focus",
      callback: async () => {
        this.settings.visualEffect = this.settings.visualEffect === "paragraph" ? "none" : "paragraph";
        await this.saveSettings();
        const leaf = this.app.workspace.getLeaf(false);
        if (leaf)
          this.controller.update(leaf);
      }
    });
    this.addCommand({
      id: "toggle-sentence-focus",
      name: "Toggle Sentence Focus",
      callback: async () => {
        this.settings.visualEffect = this.settings.visualEffect === "sentence" ? "none" : "sentence";
        await this.saveSettings();
        const leaf = this.app.workspace.getLeaf(false);
        if (leaf)
          this.controller.update(leaf);
      }
    });
    this.addCommand({
      id: "toggle-typewriter-scroll",
      name: "Toggle Typewriter Scroll",
      callback: async () => {
        this.settings.enableTypewriterScroll = !this.settings.enableTypewriterScroll;
        await this.saveSettings();
        const leaf = this.app.workspace.getLeaf(false);
        if (leaf)
          this.controller.update(leaf);
      }
    });
    this.addCommand({
      id: "toggle-frontmatter-hiding",
      name: "Toggle Frontmatter Hiding",
      callback: async () => {
        this.settings.enableFrontmatterHiding = !this.settings.enableFrontmatterHiding;
        await this.saveSettings();
        const leaf = this.app.workspace.getLeaf(false);
        if (leaf)
          this.controller.update(leaf);
      }
    });
    this.addCommand({
      id: "toggle-zen-ui",
      name: "Toggle Zen UI",
      callback: async () => {
        this.settings.enableZenUi = !this.settings.enableZenUi;
        await this.saveSettings();
        const leaf = this.app.workspace.getLeaf(false);
        if (leaf)
          this.controller.update(leaf);
      }
    });
    this.addCommand({
      id: "toggle-active-line-focus",
      name: "Toggle Active Line Focus",
      callback: async () => {
        this.settings.visualEffect = this.settings.visualEffect === "active-line" ? "none" : "active-line";
        await this.saveSettings();
        const leaf = this.app.workspace.getLeaf(false);
        if (leaf)
          this.controller.update(leaf);
      }
    });
    this.addSettingTab(new FocusModeSettingTab(this.app, this));
  }
  onunload() {
    var _a;
    const activeLeaf = (_a = this.app.workspace.getActiveViewOfType(Object)) == null ? void 0 : _a.leaf;
    if (activeLeaf) {
      this.controller.deactivate(activeLeaf);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.observer) {
      this.observer.updateSettings(this.settings);
    }
    const activeLeaf = this.app.workspace.getLeaf(false);
    if (activeLeaf) {
      this.observer.onActiveLeafChange(activeLeaf, true);
    }
  }
};
